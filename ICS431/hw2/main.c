#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>
#include <time.h>

// Global variable to hold the child's PID so the signal handler can access it
pid_t child_pid = 0;

// Function to handle the SIGINT signal (Ctrl+C)
void handle_sigint(int sig) {
    // Send the SIGTERM signal to the child process to terminate it
    kill(child_pid, SIGTERM);
}

int main() {
    // Initialize pipe for interprocess communication
    int fd[2];
    if (pipe(fd) == -1) {
        perror("Pipe failed");
        exit(1);
    }

    // Create a child process
    child_pid = fork();

    if (child_pid == -1) {
        // If fork() returns -1, an error occurred.
        perror("Fork failed");
        exit(1);
    }

    if (child_pid > 0) {
        // This block will be executed by the parent process.

        // Register the new signal handler for the SIGINT signal
        signal(SIGINT, handle_sigint);

        // Close the write-end of the pipe, I'm not going to use it.
        close(fd[1]);

        int status;
        int count;

        // Wait for the child process to terminate
        waitpid(child_pid, &status, 0);

        // Read the count of numbers from the pipe
        read(fd[0], &count, sizeof(count));

        // Close the read-end of the pipe
        close(fd[0]);

        // Print the count of random numbers generated by the child process
        printf("\nChild process terminated after printing %d numbers.\n", count);

        // End of parent process
        exit(0);
    } else {
        // This block will be executed by the child process.

        // Seeding the random number generator
        srand(time(0));

        // Close the read-end of the pipe, I'm not going to use it.
        close(fd[0]);

        int count = 0;

        // Infinite loop to print random numbers
        while (1) {
            // Generate a random number and print it
            int num = rand();
            printf("%d\n", num);
            fflush(stdout); // Flush the output buffer
            count++;
            // Simple delay to make the program output readable
            sleep(1);
        }

        // Write the count of numbers to the pipe
        write(fd[1], &count, sizeof(count));


        // Close the write-end of the pipe
        close(fd[1]);

        // Normally we wouldn't reach here because the loop is infinite
        // Termination should occur via SIGTERM signal sent by the parent
        exit(0);
    }
}
